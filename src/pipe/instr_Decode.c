/**************************************************************************
 * C S 429 system emulator
 * 
 * instr_Decode.c - Decode stage of instruction processing pipeline.
 **************************************************************************/ 

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <assert.h>
#include "err_handler.h"
#include "instr.h"
#include "instr_pipeline.h"
#include "forward.h"
#include "machine.h"
#include "hw_elts.h"

#define SP_NUM 31
#define XZR_NUM 32

extern machine_t guest;
extern mem_status_t dmem_status;

extern int64_t W_wval;

/*
 * Control signals for D, X, M, and W stages.
 * Generated by D stage logic.
 * D control signals are consumed locally. 
 * Others must be buffered in pipeline registers.
 * STUDENT TO-DO:
 * Generate the correct control signals for this instruction's
 * future stages and write them to the corresponding struct.
 */

static comb_logic_t 
generate_DXMW_control(opcode_t op,
                      d_ctl_sigs_t *D_sigs, x_ctl_sigs_t *X_sigs, m_ctl_sigs_t *M_sigs, w_ctl_sigs_t *W_sigs) {
    if(op == OP_STUR){
        D_sigs->src2_sel = true;
        M_sigs->dmem_write = true;
    }
    else{
        D_sigs->src2_sel = false;
        M_sigs->dmem_write = false;
    }
    if(op == OP_ADDS_RR || op == OP_ANDS_RR || op == OP_SUBS_RR || op == OP_CMP_RR || op == OP_TST_RR || op == OP_ORR_RR ||
        op == OP_EOR_RR || op == OP_MVN || op == OP_CSEL || op == OP_CSINV || op == OP_CSINC || op == OP_CSNEG){
            X_sigs->valb_sel = true;
    }
    else{
        X_sigs->valb_sel = false;
    }
    if(op == OP_ADDS_RR || op == OP_ANDS_RR || op == OP_SUBS_RR || op == OP_CMP_RR || op == OP_TST_RR){
        X_sigs->set_CC = true;
    }
    else{
        X_sigs->set_CC = false;
    }
    if(op == OP_LDUR){
        M_sigs->dmem_read = true;
        W_sigs->wval_sel = true;
    }
    else{
        M_sigs->dmem_read = false;
        W_sigs->wval_sel = false;
    }

    if(op == OP_BL || op == OP_BLR){
        W_sigs->dst_sel = true;
    }
    else{
        W_sigs->dst_sel = false;
    }

    if(op == OP_STUR || op == OP_B || op == OP_B_COND || op == OP_RET || op == OP_NOP || op == OP_HLT || op == OP_CMP_RR || op == OP_TST_RR || op == OP_CBZ || op == OP_CBNZ || op == OP_BR){
        W_sigs->w_enable = false;
    }
    else{
        W_sigs->w_enable = true;
    }
    if (op == OP_NOP) {
        W_sigs->w_enable = false;
        W_sigs->dst_sel = false;
        W_sigs->wval_sel = false;
    }
    return;
}

/*
 * Logic for extracting the immediate value for M-, I-, and RI-format instructions.
 * STUDENT TO-DO:
 * Extract the immediate value and write it to *imm.
 */

static comb_logic_t 
extract_immval(uint32_t insnbits, opcode_t op, int64_t *imm) {
    switch(op){
        case OP_LDUR:
        case OP_STUR:
            *imm = bitfield_s64(insnbits, 12, 9) & 0x1FF;
            break;
        case OP_MOVK:
        case OP_MOVZ:
            *imm = bitfield_s64(insnbits, 5, 16) & 0xFFFF;
            break;
        case OP_LSL:
            *imm = 64 - ((insnbits >> 16) & 0x3f);
            break;
        case OP_LSR:
        case OP_ASR:
            //*imm = bitfield_s64(insnbits, 10, 12) & 0xFFF;
            *imm = (insnbits >> 16 & 0x3F);
            break;
        case OP_B:
        case OP_BL:
            *imm = (bitfield_s64(insnbits, 0, 25) << 2) & 0x1FFFFFF;
            break;
        case OP_B_COND:
        case OP_CBNZ:
        case OP_CBZ:
            *imm = bitfield_s64(insnbits, 5, 19) & 0x7FFFF;
            break;
        case OP_ADD_RI:
        case OP_SUB_RI:
            //cast to unsigned
            //*imm = (uint64_t)bitfield_s64(insnbits, 10, 12) & 0xFFF;
            *imm = bitfield_u32(insnbits, 10, 12) & 0xFFF;
            /*
            if(*imm < 0){
                *imm = 4096+*imm;
            }
            */
            break;
        case OP_ADRP:
            *imm = ((bitfield_u32(insnbits, 5, 19) & 0x7FFFF) << 14) | ((bitfield_u32(insnbits, 29, 2) & 0x3) << 12);
            break;
        default:
            *imm = 0;
            break;
    }
    return;
}

/*
 * Logic for determining the ALU operation needed for this opcode.
 * STUDENT TO-DO:
 * Determine the ALU operation based on the given opcode
 * and write it to *ALU_op.
 */
static comb_logic_t
decide_alu_op(opcode_t op, alu_op_t *ALU_op) {
    switch (op)
    {
    case OP_MOVZ:
    case OP_MOVK:
        *ALU_op = MOV_OP;
        break;
    case OP_ADRP:
    case OP_ADD_RI:
    case OP_ADDS_RR:
    case OP_LDUR:
    case OP_STUR:
        *ALU_op = PLUS_OP;
        break;
    case OP_SUB_RI:
    case OP_SUBS_RR:
    case OP_CMP_RR:
        *ALU_op = MINUS_OP;
        break;
    case OP_MVN:
        *ALU_op = INV_OP;
        break;
    case OP_ORR_RR:
        *ALU_op = OR_OP;
        break;
    case OP_EOR_RR:
        *ALU_op = EOR_OP;
        break;
    case OP_ANDS_RR:
    case OP_TST_RR:
        *ALU_op = AND_OP;
        break;
    case OP_LSL:
        *ALU_op = LSL_OP;
        break;
    case OP_LSR:
        *ALU_op = LSR_OP;
        break;
    case OP_ASR:
        *ALU_op = ASR_OP;
        break;
    case OP_CSEL:
        *ALU_op = CSEL_OP;
        break;
    case OP_CSINV:
        *ALU_op = CSINV_OP;
        break;
    case OP_CSINC:
        *ALU_op = CSINC_OP;
        break;
    case OP_CSNEG:
        *ALU_op = CSNEG_OP;
        break;
    default:
        *ALU_op = PASS_A_OP;
        break;
    }
    return;
}

/*
 * Utility functions for copying over control signals across a stage.
 * STUDENT TO-DO:
 * Copy the input signals from the input side of the pipeline
 * register to the output side of the register.
 */

comb_logic_t 
copy_m_ctl_sigs(m_ctl_sigs_t *dest, m_ctl_sigs_t *src) {
    dest->dmem_read = src->dmem_read;
    dest->dmem_write = src->dmem_write;
    return;
}

comb_logic_t 
copy_w_ctl_sigs(w_ctl_sigs_t *dest, w_ctl_sigs_t *src) {
    dest->dst_sel = src->dst_sel;
    dest->w_enable = src->w_enable;
    dest->wval_sel = src->wval_sel;
    return;
}

comb_logic_t
extract_regs(uint32_t insnbits, opcode_t op, 
             uint8_t *src1, uint8_t *src2, uint8_t *dst) {
    if(op == OP_LDUR || op == OP_STUR) {
        *src1 = bitfield_u32(insnbits, 5, 5);
        *dst = bitfield_u32(insnbits, 0, 5);
        *src2 = bitfield_u32(insnbits, 0, 5);
        if (*src2 == SP_NUM) *src2 += 2;
    }
    else if(op == OP_MOVK || op == OP_MOVZ || op == OP_ADRP) {
        if (op ==OP_MOVK) {
            *src1 = bitfield_u32(insnbits, 0, 5);
        }
        *dst = bitfield_u32(insnbits, 0, 5);
    }
    else if(op == OP_ADDS_RR || op == OP_SUBS_RR || op == OP_MVN || op == OP_ORR_RR || op == OP_EOR_RR
            || op == OP_ANDS_RR || op == OP_CMP_RR || op == OP_TST_RR) {
        *src1 = bitfield_u32(insnbits, 5, 5);
        *src2 = bitfield_u32(insnbits, 16, 5);
        *dst = bitfield_u32(insnbits, 0, 5);
        if (*dst == SP_NUM) *dst += 1;
        if (*src1 == SP_NUM) *src1 += 1;
        if (*src2 == SP_NUM) *src2 += 1;
    }
    else if(op == OP_ADD_RI || op == OP_SUB_RI || op == OP_LSL || op == OP_LSR || op == OP_ASR) {
        *src1 = bitfield_u32(insnbits, 5, 5);
        *dst = bitfield_u32(insnbits, 0, 5);
    }
    else if(op == OP_RET || op == OP_BR || op == OP_BLR) {
        *src1 = bitfield_u32(insnbits, 5, 5);
        *dst = bitfield_u32(insnbits, 15, 5);
    } else if (op == OP_BLR) {
        *src1 = bitfield_u32(insnbits, 5, 5);
        *dst = 30;
    }
    else if(op == OP_ADRP){
        *dst = bitfield_u32(insnbits, 0, 5);
    } else if (op == OP_NOP) {
        *dst = 0;
    } else if (op == OP_CSEL || op == OP_CSINV || op == OP_CSINC || op == OP_CSNEG) {
        *src1 = bitfield_u32(insnbits, 5, 5);
        *src2 = bitfield_u32(insnbits, 16, 5);
        *dst = bitfield_u32(insnbits, 0, 5);
        // if (*dst == SP_NUM) *dst += 1;
        // if (*src1 == SP_NUM) *src1 += 1;
        // if (*src2 == SP_NUM) *src2 += 1;
    } else if(op == OP_CBZ || op == OP_CBNZ){
        *src1 = bitfield_u32(insnbits, 0, 5);
    }
    return;
}

/*
 * Decode stage logic.
 * STUDENT TO-DO:
 * Implement the decode stage.
 * 
 * Use `in` as the input pipeline register,
 * and update the `out` pipeline register as output.
 * Additionally, make sure the register file is updated
 * with W_out's output when you call it in this stage.
 * 
 * You will also need the following helper functions:
 * generate_DXMW_control, regfile, extract_immval,
 * and decide_alu_op.
 */


comb_logic_t decode_instr(d_instr_impl_t *in, x_instr_impl_t *out) {
    if (in->status == STAT_AOK || in->status == STAT_BUB) {
        d_ctl_sigs_t ctl;

        x_ctl_sigs_t x_ctl;
        m_ctl_sigs_t m_ctl;
        w_ctl_sigs_t w_ctl;

        generate_DXMW_control(in->op, &ctl, &x_ctl, &m_ctl, &w_ctl);
        uint8_t reg1;
        uint8_t reg2;
        uint8_t dest;
        extract_regs(in->insnbits, in->op, &reg1, &reg2, &dest);
        int64_t imm;
        extract_immval(in->insnbits, in->op, &imm);
        alu_op_t ALU_op;
        decide_alu_op(in->op, &ALU_op);
        uint64_t val1;
        uint64_t val2;

        if(w_ctl.dst_sel){
            dest = 30;
        }
        if (in->op == OP_SUBS_RR && dest == XZR_NUM) {
            w_ctl.w_enable = false;
        }
        //w_ctl.w_enable
        regfile(reg1, reg2, dest, W_wval, false, &val1, &val2);
        
        out->seq_succ_PC = in->seq_succ_PC;
        out->ALU_op = ALU_op;
        //cond
        if(in->op == OP_B_COND){
            out->cond = bitfield_u32(in->insnbits, 0, 4);
        }
        if(in->op == OP_CSEL || in->op == OP_CSINV || in->op == OP_CSINC || in->op == OP_CSNEG){
            out->cond = bitfield_u32(in->insnbits, 12, 4);
        }
        out->val_a = val1;
        out->val_b = val2;
        out->val_imm = imm;
        if(in->op == OP_MOVK || in->op == OP_MOVZ){
            out->val_hw = bitfield_u32(in->insnbits, 21, 2) << 4;
        }
        else{
            out->val_hw = 0;
        }
        
        out->dst = dest;
        copy_m_ctl_sigs(&(out->M_sigs), &m_ctl);
        copy_w_ctl_sigs(&(out->W_sigs), &w_ctl);
        out->X_sigs.set_CC = x_ctl.set_CC;
        out->X_sigs.valb_sel = x_ctl.valb_sel;

        uint64_t alu_valb;
        if(out->X_sigs.valb_sel){
            alu_valb = out->val_b;
        }
        else{
            alu_valb = out->val_imm;
        }
        forward_reg(reg1, reg2, X_out->dst, M_out->dst, W_out->dst, M_in->val_ex, M_out->val_ex, W_in->val_mem,
                    W_out->val_ex, W_out->val_mem, W_in->W_sigs.wval_sel, W_out->W_sigs.wval_sel,
                    M_in->W_sigs.w_enable, M_out->W_sigs.w_enable, W_out->W_sigs.w_enable, &(out->val_a), &(out->val_b));
        if(in->op == OP_MVN){
            out->val_a = 0;
        }
        else if(in->op == OP_ADRP){
            out->val_a = in->adrp_val;
        } 
        else if (in->op == OP_MOVK) { // SPECIAL CASE FOR MOVK
            unsigned long mask = 0xFFFF;
            mask = mask << out->val_hw;
            mask = ~mask;
            out->val_a = out->val_a & mask;
        }
        
    } else {
        uint8_t src1 = 32;
        uint8_t src2 = 32;
        if (W_out->status == STAT_AOK || W_out->status == STAT_BUB) {
            regfile(src1, src2, W_out->dst, W_wval, W_out->W_sigs.w_enable, &(out->val_a), &(out->val_b));
        }
    }
    out->print_op = in->print_op;
    out->status = in->status;
    out->op = in->op;
    return;
}